<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ì†Œì¥ë‹˜ ì „ìš© ë°”ë‘‘/ì˜¤ëª©</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111826;
      --wood:#c49a6c;
      --wood2:#b78957;
      --line: rgba(0,0,0,.65);
      --text:#e7eefc;
      --muted: rgba(231,238,252,.65);
      --btn:#1a2436;
      --btn2:#24314a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex; flex-direction: column; align-items: center;
      min-height: 100vh; overflow-x: hidden;
    }
    header{ width:100%; padding: 20px 20px 10px; max-width: 600px; display:flex; justify-content:space-between; align-items:center;}
    h1{ font-size:1.4rem; margin:0; font-weight:700; color:var(--text); letter-spacing:-0.02em;}
    
    .status-bar{
      width:90%; max-width:600px; background:var(--panel); border-radius:var(--radius);
      padding:15px 20px; margin-bottom:15px; display:flex; justify-content:space-between; align-items:center;
      box-shadow:var(--shadow);
    }
    .turn-info{ display:flex; align-items:center; gap:10px; font-weight:600;}
    .dot{ width:12px; height:12px; border-radius:50%; }
    .black-dot{ background:#000; border:1px solid rgba(255,255,255,0.2); }
    .white-dot{ background:#fff; border:1px solid rgba(0,0,0,0.1); }
    
    .board-container{
      position:relative; width:95vw; height:95vw; max-width:600px; max-height:600px;
      background: var(--wood); border-radius: 8px; box-shadow: var(--shadow);
      display:flex; align-items:center; justify-content:center; padding:10px;
      border: 4px solid var(--wood2);
    }
    canvas{ width:100%; height:100%; touch-action:none; cursor:crosshair; }

    .btn-group{
      width:90%; max-width:600px; margin-top:20px; display:grid; grid-template-columns: 1fr 1fr; gap:10px; padding-bottom:40px;
    }
    .btn{
      border:none; border-radius:12px; padding:14px; font-size:0.95rem; font-weight:600;
      color:var(--text); background:var(--btn); cursor:pointer; transition:all 0.2s;
      display:flex; align-items:center; justify-content:center; gap:8px;
    }
    .btn:active{ transform:scale(0.96); opacity:0.8; }
    .btn.secondary{ background: var(--btn2); }
    .btn.danger{ background: rgba(239, 68, 68, 0.2); color:#f87171; grid-column: span 2; }
    .mode-active { background: #c49a6c !important; color: #000 !important; }

    .caps-info{ font-size:0.85rem; color:var(--muted); }
  </style>
</head>
<body>

<header>
  <h1 id="appTitle">ì£¼ì¸ë‹˜ì˜ ë°”ë‘‘</h1>
  <div class="caps-info">
    í‘ ì¡ìŒ: <span id="capBlack">0</span> / ë°± ì¡ìŒ: <span id="capWhite">0</span>
  </div>
</header>

<div class="status-bar">
  <div class="turn-info">
    <div id="turnDot" class="dot black-dot"></div>
    <span id="turnText">í‘ì˜ ì°¨ë¡€</span>
  </div>
  <div id="modeDisplay" style="font-size:0.8rem; opacity:0.7;">í˜„ì¬ ëª¨ë“œ: ë°”ë‘‘</div>
</div>

<div class="board-container">
  <canvas id="goBoard"></canvas>
</div>

<div class="btn-group">
  <button id="modeBtn" class="btn">ğŸ” ëª¨ë“œ ì „í™˜: ì˜¤ëª©</button>
  <button id="undoBtn" class="btn secondary">í•œ ìˆ˜ ë˜ëŒë¦¬ê¸°</button>
  <button id="passBtn" class="btn secondary">íŒ¨ìŠ¤</button>
  <button id="resetBtn" class="btn danger">íŒ ë¹„ìš°ê¸°</button>
</div>

<script>
  const canvas = document.getElementById('goBoard');
  const ctx = canvas.getContext('2d');
  const SIZE = 19;
  const EMPTY = 0, BLACK = 1, WHITE = 2;
  
  let board = Array.from({length:SIZE}, () => Array(SIZE).fill(EMPTY));
  let turn = BLACK;
  let history = [];
  let captures = { black: 0, white: 0 };
  let isOmokMode = false; // ì´ˆê¸°ê°’ ë°”ë‘‘

  function init() {
    const saved = localStorage.getItem("go19_v2_state");
    if(saved) {
      const data = JSON.parse(saved);
      board = data.board;
      turn = data.turn;
      history = data.history || [];
      captures = data.captures || {black:0, white:0};
      isOmokMode = !!data.isOmokMode;
    }
    updateUI();
    resize();
    window.addEventListener('resize', resize);
  }

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.parentElement.getBoundingClientRect();
    const side = Math.min(rect.width, rect.height) - 20;
    canvas.width = side * dpr;
    canvas.height = side * dpr;
    ctx.scale(dpr, dpr);
    canvas.style.width = side + 'px';
    canvas.style.height = side + 'px';
    draw();
  }

  function draw() {
    const s = canvas.clientWidth;
    const padding = s / (SIZE + 1);
    const spacing = (s - padding * 2) / (SIZE - 1);
    
    ctx.clearRect(0,0,s,s);
    ctx.strokeStyle = "rgba(0,0,0,0.6)";
    ctx.lineWidth = 1;

    // ì„  ê·¸ë¦¬ê¸°
    for(let i=0; i<SIZE; i++) {
      ctx.beginPath();
      ctx.moveTo(padding + i*spacing, padding);
      ctx.lineTo(padding + i*spacing, s - padding);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(padding, padding + i*spacing);
      ctx.lineTo(s - padding, padding + i*spacing);
      ctx.stroke();
    }

    // í™”ì (Star points)
    const stars = [3, 9, 15];
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    stars.forEach(r => stars.forEach(c => {
      ctx.beginPath();
      ctx.arc(padding + c*spacing, padding + r*spacing, 3, 0, Math.PI*2);
      ctx.fill();
    }));

    // ëŒ ê·¸ë¦¬ê¸°
    for(let y=0; y<SIZE; y++){
      for(let x=0; x<SIZE; x++){
        if(board[y][x] !== EMPTY){
          const cx = padding + x*spacing;
          const cy = padding + y*spacing;
          ctx.beginPath();
          ctx.arc(cx, cy, spacing*0.45, 0, Math.PI*2);
          ctx.fillStyle = board[y][x] === BLACK ? "#111" : "#fff";
          ctx.shadowBlur = 4; ctx.shadowColor = "rgba(0,0,0,0.3)";
          ctx.fill();
          ctx.shadowBlur = 0;
          if(board[y][x] === WHITE) { ctx.strokeStyle="#ccc"; ctx.stroke(); }
        }
      }
    }

    // ë§ˆì§€ë§‰ ìˆ˜ í‘œì‹œ (ë¹¨ê°„ ì )
    if(history.length > 0) {
      const last = history[history.length-1];
      if(!last.pass && last.x !== -1) {
        ctx.fillStyle = "#ff4444";
        ctx.beginPath();
        ctx.arc(padding + last.x*spacing, padding + last.y*spacing, 4, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const s = rect.width;
    const padding = s / (SIZE + 1);
    const spacing = (s - padding * 2) / (SIZE - 1);
    const x = Math.round((e.clientX - rect.left - padding) / spacing);
    const y = Math.round((e.clientY - rect.top - padding) / spacing);

    if(x >= 0 && x < SIZE && y >= 0 && y < SIZE && board[y][x] === EMPTY) {
      board[y][y] = EMPTY; // í˜¹ì‹œ ëª¨ë¥¼ ì—ëŸ¬ ë°©ì§€
      board[y][x] = turn;

      let captured = [];
      if(!isOmokMode) { // ë°”ë‘‘ ëª¨ë“œì¼ ë•Œë§Œ ìº¡ì²˜ í™•ì¸
        captured = getCaptured(x, y, turn);
        if(captured.length === 0 && isSuicide(x, y, turn)) {
          board[y][x] = EMPTY;
          alert("ìì‚´ìˆ˜ì…ë‹ˆë‹¤!");
          return;
        }
        captured.forEach(([cx, cy]) => {
          board[cy][cx] = EMPTY;
          if(turn === BLACK) captures.black++; else captures.white++;
        });
      }

      history.push({x, y, turn, removed: captured, isOmok: isOmokMode});
      turn = (turn === BLACK) ? WHITE : BLACK;
      updateUI();
      saveToLocal();
      draw();
    }
  });

  // ë°”ë‘‘ ë¡œì§ (ìº¡ì²˜ í™•ì¸)
  function getCaptured(x, y, color) {
    const opp = (color === BLACK) ? WHITE : BLACK;
    let totalRemoved = [];
    [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
      const nx = x + dx, ny = y + dy;
      if(nx>=0 && nx<SIZE && ny>=0 && ny<SIZE && board[ny][nx] === opp) {
        const group = getGroup(nx, ny);
        if(!hasLiberty(group)) totalRemoved = totalRemoved.concat(group);
      }
    });
    return totalRemoved;
  }

  function getGroup(x, y) {
    const color = board[y][x];
    const group = [];
    const visited = new Set();
    const stack = [[x, y]];
    while(stack.length) {
      const [cx, cy] = stack.pop();
      const key = `${cx},${cy}`;
      if(!visited.has(key)) {
        visited.add(key);
        group.push([cx, cy]);
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
          const nx = cx + dx, ny = cy + dy;
          if(nx>=0 && nx<SIZE && ny>=0 && ny<SIZE && board[ny][nx] === color) stack.push([nx, ny]);
        });
      }
    }
    return group;
  }

  function hasLiberty(group) {
    for(const [gx, gy] of group) {
      const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
      for(const [dx, dy] of dirs) {
        const nx = gx + dx, ny = gy + dy;
        if(nx>=0 && nx<SIZE && ny>=0 && ny<SIZE && board[ny][nx] === EMPTY) return true;
      }
    }
    return false;
  }

  function isSuicide(x, y, color) {
    const group = getGroup(x, y);
    return !hasLiberty(group);
  }

  // UI ì—…ë°ì´íŠ¸
  function updateUI() {
    document.getElementById("turnDot").className = "dot " + (turn === BLACK ? "black-dot" : "white-dot");
    document.getElementById("turnText").innerText = (turn === BLACK ? "í‘" : "ë°±") + "ì˜ ì°¨ë¡€";
    document.getElementById("capBlack").innerText = captures.black;
    document.getElementById("capWhite").innerText = captures.white;
    
    const modeBtn = document.getElementById("modeBtn");
    const appTitle = document.getElementById("appTitle");
    const modeDisplay = document.getElementById("modeDisplay");

    if(isOmokMode) {
      modeBtn.innerText = "ğŸ” ëª¨ë“œ ì „í™˜: ë°”ë‘‘";
      appTitle.innerText = "ì£¼ì¸ë‹˜ì˜ ì˜¤ëª©";
      modeDisplay.innerText = "í˜„ì¬ ëª¨ë“œ: ì˜¤ëª© (ì¡ê¸° ë¶ˆê°€)";
    } else {
      modeBtn.innerText = "ğŸ” ëª¨ë“œ ì „í™˜: ì˜¤ëª©";
      appTitle.innerText = "ì£¼ì¸ë‹˜ì˜ ë°”ë‘‘";
      modeDisplay.innerText = "í˜„ì¬ ëª¨ë“œ: ë°”ë‘‘";
    }
  }

  function saveToLocal() {
    localStorage.setItem("go19_v2_state", JSON.stringify({board, turn, history, captures, isOmokMode}));
  }

  // ë²„íŠ¼ ì´ë²¤íŠ¸
  document.getElementById("modeBtn").addEventListener("click", () => {
    isOmokMode = !isOmokMode;
    updateUI();
    saveToLocal();
  });

  document.getElementById("undoBtn").addEventListener("click", () => {
    if(history.length === 0) return;
    const last = history.pop();
    board[last.y][last.x] = EMPTY;
    if(last.removed) {
      const opp = (last.turn === BLACK) ? WHITE : BLACK;
      last.removed.forEach(([rx, ry]) => {
        board[ry][rx] = opp;
        if(last.turn === BLACK) captures.black--; else captures.white--;
      });
    }
    turn = last.turn;
    updateUI();
    saveToLocal();
    draw();
  });

  document.getElementById("passBtn").addEventListener("click", () => {
    history.push({x: -1, y: -1, turn, pass: true});
    turn = (turn === BLACK) ? WHITE : BLACK;
    updateUI();
    saveToLocal();
    draw();
  });

  document.getElementById("resetBtn").addEventListener("click", () => {
    if(confirm("íŒì„ ë¹„ìš¸ê¹Œìš”?")) {
      board = Array.from({length:SIZE}, () => Array(SIZE).fill(EMPTY));
      history = [];
      captures = {black:0, white:0};
      turn = BLACK;
      saveToLocal();
      updateUI();
      draw();
    }
  });

  init();
</script>
</body>
</html>
