<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>주인님의 바둑</title>
  <link rel="manifest" href="manifest.webmanifest" />
  <meta name="theme-color" content="#c49a6c" />
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111826;
      --wood:#c49a6c;
      --wood2:#b78957;
      --line: rgba(0,0,0,.65);
      --text:#e7eefc;
      --muted: rgba(231,238,252,.65);
      --btn:#1a2436;
      --btn2:#24314a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", Arial, sans-serif;
      background: radial-gradient(1200px 600px at 50% -20%, rgba(120,160,255,.18), transparent 60%),
                  linear-gradient(180deg, #0b0f14, #070a0f);
      color:var(--text);
      min-height:100svh;
      display:flex;
      justify-content:center;
      padding: 16px 12px 24px;
    }
    .app{
      width:min(520px, 100%);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    header{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:12px;
      padding: 10px 12px;
      background: rgba(17,24,38,.7);
      border: 1px solid rgba(255,255,255,.06);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .title .h{
      font-size: 18px;
      font-weight: 800;
      letter-spacing: -0.2px;
    }
    .title .sub{
      font-size: 12px;
      color: var(--muted);
    }
    .turn{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.06);
      border-radius: 999px;
      user-select:none;
    }
    .dot{
      width:14px; height:14px; border-radius:50%;
      box-shadow: inset 0 1px 2px rgba(255,255,255,.25), 0 2px 10px rgba(0,0,0,.4);
      border: 1px solid rgba(255,255,255,.18);
    }
    .dot.black{ background:#111; border-color: rgba(255,255,255,.12); }
    .dot.white{ background:#f3f3f3; border-color: rgba(0,0,0,.12); }
    .turn span{ font-size: 13px; color: var(--text); }

    .boardWrap{
      background: linear-gradient(145deg, var(--wood), var(--wood2));
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(0,0,0,.18);
    }

    /* 정사각형 유지 */
    .square{
      width:100%;
      aspect-ratio: 1 / 1;
      position:relative;
      border-radius: 14px;
      overflow:hidden;
      touch-action: manipulation;
      background: linear-gradient(180deg, rgba(255,255,255,.06), transparent 30%),
                  radial-gradient(800px 800px at 70% 10%, rgba(0,0,0,.12), transparent 55%);
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
    }

    .bar{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:space-between;
      padding: 10px 12px;
      background: rgba(17,24,38,.7);
      border: 1px solid rgba(255,255,255,.06);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .btns{
      display:flex;
      gap:10px;
      flex: 1 1 auto;
      flex-wrap:wrap;
    }
    button{
      appearance:none;
      border:none;
      outline:none;
      color: var(--text);
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 700;
      letter-spacing: -0.2px;
      box-shadow: 0 10px 20px rgba(0,0,0,.25);
      cursor:pointer;
      user-select:none;
    }
    button:active{
      transform: translateY(1px);
      filter: brightness(.98);
    }
    .hint{
      font-size: 12px;
      color: var(--muted);
      display:flex;
      align-items:center;
      gap:8px;
      margin-left:auto;
    }
    .hint kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
      padding: 3px 6px;
      border-radius: 8px;
      color: var(--text);
    }
  </style>

</head>
<body>
  <div class="app">
    <header>
      <div class="title">
        <div class="h">주인님의 바둑 (19×19)</div>
        <div class="sub">친구랑 번갈아 두기 · 새 게임 · 되돌리기 · 패스</div>
      </div>
      <div class="turn" id="turnPill" title="현재 차례">
        <div class="dot black" id="turnDot"></div>
        <span id="turnText">흑 차례</span>
      </div>
    </header>

    <div class="boardWrap">
      <div class="square">
        <canvas id="board"></canvas>
      </div>
    </div>

    <div class="bar">
      <div class="btns">
        <button id="newGameBtn">새 게임</button>
        <button id="undoBtn">한 수 되돌리기</button>
        <button id="passBtn">패스</button>
      </div>
<div class="sub" style="margin-top:6px; color: rgba(231,238,252,.75); font-size:12px;">
  잡은 돌 — 흑: <b id="capBlack">0</b> · 백: <b id="capWhite">0</b>
</div>

      <div class="hint">
        <span>팁:</span>
        <kbd>탭</kbd><span>으로 착수</span>
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== PWA: Service Worker 등록 ======
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw.js").catch(() => {});
    });
  }

  // ====== 바둑판 상태 ======
  const SIZE = 19; // 19x19
  const EMPTY = 0, BLACK = 1, WHITE = 2;



// ====== 사운드 (짧게 잘라 재생) ======
// 같은 폴더에 place.mp3, capture.mp3 를 두세요.
const SFX = {
  enabled: true,
  placeSrc: "./place.mp3",
  captureSrc: "./capture.mp3",
  // 34초짜리 파일이어도 앞부분만 "짧게" 재생하면 됩니다.
  placeMs: 600,    // 착수 소리 길이(ms) - 취향대로 조절
  captureMs: 600,  // 따먹기 소리 길이(ms)
  volume: 0.7    // 0.0 ~ 1.0
};

function playSfx(src, ms){
  if (!SFX.enabled) return;
  try{
    const a = new Audio(src);
    a.preload = "auto";
    a.volume = SFX.volume;
    // 사용자 제스처(pointerup) 안에서 호출되므로 모바일에서도 보통 재생됩니다.
    a.currentTime = 0;
    const p = a.play();
    // 일부 브라우저는 play()가 Promise를 반환합니다.
    if (p && typeof p.catch === "function") p.catch(() => {});
    // ms 이후 강제 종료(긴 음원도 짧게 끊어쓰기)
    setTimeout(() => {
      try{ a.pause(); a.currentTime = 0; }catch(e){}
    }, ms);
  }catch(e){}
}

  let board = Array.from({length: SIZE}, () => Array(SIZE).fill(EMPTY));
let captures = { black: 0, white: 0 };

const capBlackEl = document.getElementById("capBlack");
const capWhiteEl = document.getElementById("capWhite");
function updateCapsUI(){
  if (capBlackEl) capBlackEl.textContent = String(captures.black);
  if (capWhiteEl) capWhiteEl.textContent = String(captures.white);
}

  let turn = BLACK;
  let history = []; // {x,y,turn}

  // ====== 캔버스 ======
  const canvas = document.getElementById("board");
  const ctx = canvas.getContext("2d");

  // DPR 대응(선명)
  function fitCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    draw();
  }

  // 격자 파라미터
  function geom() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const pad = Math.min(w, h) * 0.025;         // 바깥 여백
    const inner = Math.min(w, h) - pad * 2;    // 실제 격자 영역
    const step = inner / (SIZE - 1);
    const ox = (w - inner) / 2;
    const oy = (h - inner) / 2;
    return {w, h, pad, inner, step, ox, oy};
  }

  function draw() {
    const {w, h, step, ox, oy} = geom();
    ctx.clearRect(0, 0, w, h);

    // 격자 선
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(0,0,0,.65)";
    ctx.beginPath();
    for (let i = 0; i < SIZE; i++) {
      const x = ox + i * step;
      const y = oy + i * step;

      // 세로
      ctx.moveTo(x, oy);
      ctx.lineTo(x, oy + (SIZE - 1) * step);
      // 가로
      ctx.moveTo(ox, y);
      ctx.lineTo(ox + (SIZE - 1) * step, y);
    }
    ctx.stroke();

    // 화점(9개)
    const starPoints = [3, 9, 15];
    ctx.fillStyle = "rgba(0,0,0,.75)";
    for (const i of starPoints) {
      for (const j of starPoints) {
        const x = ox + i * step;
        const y = oy + j * step;
        ctx.beginPath();
        ctx.arc(x, y, step * 0.10, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // 돌 그리기
    for (let y = 0; y < SIZE; y++) {
      for (let x = 0; x < SIZE; x++) {
        const v = board[y][x];
        if (v === EMPTY) continue;
        drawStone(x, y, v);
      }
    }

    // 마지막 수 표시(빨간 점)
    const last = history[history.length - 1];
    if (last && !last.pass) {
      const {x, y} = last;
      const {step, ox, oy} = geom();
      const cx = ox + x * step;
      const cy = oy + y * step;
      ctx.fillStyle = "rgba(220,40,40,.9)";
      ctx.beginPath();
      ctx.arc(cx, cy, step * 0.12, 0, Math.PI * 2);
      ctx.fill();
    }
  }
function inBounds(x, y){ return x >= 0 && x < SIZE && y >= 0 && y < SIZE; }

function neighbors(x, y){
  return [
    [x-1, y], [x+1, y],
    [x, y-1], [x, y+1]
  ].filter(([nx, ny]) => inBounds(nx, ny));
}

function getGroupAndLiberties(x, y){
  const color = board[y][x];
  const stack = [[x, y]];
  const visited = new Set([`${x},${y}`]);
  const stones = [];
  let liberties = 0;

  while (stack.length){
    const [cx, cy] = stack.pop();
    stones.push([cx, cy]);

    for (const [nx, ny] of neighbors(cx, cy)){
      const v = board[ny][nx];
      if (v === EMPTY){
        liberties++;
      } else if (v === color){
        const key = `${nx},${ny}`;
        if (!visited.has(key)){
          visited.add(key);
          stack.push([nx, ny]);
        }
      }
    }
  }
  return { color, stones, liberties };
}

function removeStones(stones){
  for (const [x, y] of stones) board[y][x] = EMPTY;
}

  function drawStone(x, y, color) {
    const {step, ox, oy} = geom();
    const cx = ox + x * step;
    const cy = oy + y * step;
    const r = step * 0.46;

    // 돌 그라데이션(심플)
    const g = ctx.createRadialGradient(cx - r*0.3, cy - r*0.3, r*0.2, cx, cy, r);
    if (color === BLACK) {
      g.addColorStop(0, "rgba(90,90,90,.9)");
      g.addColorStop(0.4, "rgba(25,25,25,.95)");
      g.addColorStop(1, "rgba(0,0,0,1)");
      ctx.strokeStyle = "rgba(255,255,255,.10)";
    } else {
      g.addColorStop(0, "rgba(255,255,255,1)");
      g.addColorStop(0.5, "rgba(240,240,240,1)");
      g.addColorStop(1, "rgba(210,210,210,1)");
      ctx.strokeStyle = "rgba(0,0,0,.10)";
    }

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.stroke();
  }

  // ====== 턴 UI ======
  const turnDot = document.getElementById("turnDot");
  const turnText = document.getElementById("turnText");

  function updateTurnUI() {
    if (turn === BLACK) {
      turnDot.className = "dot black";
      turnText.textContent = "흑 차례";
    } else {
      turnDot.className = "dot white";
      turnText.textContent = "백 차례";
    }
  }

  // ====== 입력(터치/클릭) ======
function getCellFromEvent(ev) {
  const rect = canvas.getBoundingClientRect();
  const {step, ox, oy} = geom();

  // pointer 이벤트는 ev.clientX/Y가 항상 있음
  const clientX = ev.clientX;
  const clientY = ev.clientY;

  const x = clientX - rect.left;
  const y = clientY - rect.top;

  const gx = Math.round((x - ox) / step);
  const gy = Math.round((y - oy) / step);

  if (gx < 0 || gx >= SIZE || gy < 0 || gy >= SIZE) return null;

  const px = ox + gx * step;
  const py = oy + gy * step;
  const dist = Math.hypot(x - px, y - py);
  if (dist > step * 0.55) return null;

  return {x: gx, y: gy};
}

 

function placeStone(x, y) {
  if (board[y][x] !== EMPTY) return;

  const me = turn;
  const opp = (me === BLACK) ? WHITE : BLACK;

  // 1) 일단 둔다
  board[y][x] = me;

  // 2) 상대 인접 그룹 중 숨(자유도) 0인 것 포획
  const removed = []; // 이번 수로 잡힌 돌 좌표들
  for (const [nx, ny] of neighbors(x, y)) {
    if (board[ny][nx] !== opp) continue;
    const g = getGroupAndLiberties(nx, ny);
    if (g.liberties === 0) {
      removed.push(...g.stones);
    }
  }

  // 실제 제거(중복 제거)
  const uniq = new Map();
  for (const [rx, ry] of removed) uniq.set(`${rx},${ry}`, [rx, ry]);
  const removedUniq = Array.from(uniq.values());
  if (removedUniq.length) removeStones(removedUniq);

  // 3) 자살수(자기 그룹 숨 0) 방지: 포획 후에도 숨이 0이면 무효
  const myGroup = getGroupAndLiberties(x, y);
  if (myGroup.liberties === 0) {
    // 되돌림
    board[y][x] = EMPTY;
    // 상대 돌 원복
    for (const [rx, ry] of removedUniq) board[ry][rx] = opp;
    return;
  }

  // 4) 캡처 카운트 반영
  const capCount = removedUniq.length;
  if (capCount > 0) {
    if (me === BLACK) captures.black += capCount;
    else captures.white += capCount;
    playSfx(SFX.captureSrc, SFX.captureMs);
  }

  // 5) 히스토리 기록(undo를 위해 잡힌 돌도 기록)
  history.push({ x, y, turn: me, removed: removedUniq, capCount });

  // 6) 턴 전환
  turn = (turn === BLACK) ? WHITE : BLACK;

  updateTurnUI();
  updateCapsUI();
  playSfx(SFX.placeSrc, SFX.placeMs);
  saveToLocal();
  draw();
}

// 모바일/데스크탑 통합: Pointer Events
canvas.addEventListener("pointerup", (ev) => {
  ev.preventDefault();
  const cell = getCellFromEvent(ev);
  if (!cell) return;
  placeStone(cell.x, cell.y);
});

  // ====== 버튼들 ======
  document.getElementById("newGameBtn").addEventListener("click", () => {
    if (!confirm("새 게임을 시작할까요? (현재 판은 사라집니다)")) return;
    board = Array.from({length: SIZE}, () => Array(SIZE).fill(EMPTY));
    turn = BLACK;
    history = [];
    updateTurnUI();
    saveToLocal();
captures = { black: 0, white: 0 };
updateCapsUI();
    draw();
  });

document.getElementById("undoBtn").addEventListener("click", () => {
  const last = history.pop();
  if (!last) return;

  // 패스였다면: 턴만 되돌림
  if (last.pass) {
    turn = last.turn;
    updateTurnUI();
    updateCapsUI();
    saveToLocal();
    draw();
    return;
  }

  // 착수 돌 제거
  board[last.y][last.x] = EMPTY;

  // 잡힌 돌 복원
  const opp = (last.turn === BLACK) ? WHITE : BLACK;
  if (last.removed && last.removed.length) {
    for (const [rx, ry] of last.removed) board[ry][rx] = opp;

    // 캡처 카운트 되돌림
    if (last.turn === BLACK) captures.black -= last.removed.length;
    else captures.white -= last.removed.length;
  }

  // 그 수를 뒀던 사람이 다시 차례
  turn = last.turn;

  updateTurnUI();
  updateCapsUI();
  saveToLocal();
  draw();
});


  document.getElementById("passBtn").addEventListener("click", () => {
    // 패스는 히스토리에 기록(되돌리기 가능)
    history.push({x: -1, y: -1, turn, pass:true});
    turn = (turn === BLACK) ? WHITE : BLACK;
    updateTurnUI();
    updateCapsUI();
    saveToLocal();
    draw();
  });

  // ====== 저장/복원(폰에 넣고 다닐 때 중요) ======
  const KEY = "go19_v1_state";
function saveToLocal(){
  try{
    localStorage.setItem(KEY, JSON.stringify({board, turn, history, captures}));
  }catch(e){}
}

function loadFromLocal(){
  try{
    const raw = localStorage.getItem(KEY);
    if(!raw) return;
    const s = JSON.parse(raw);
    if(!s || !s.board || !s.history) return;

    board = s.board;
    turn = s.turn ?? BLACK;
    history = s.history ?? [];
    captures = s.captures ?? { black: 0, white: 0 };
  }catch(e){}
}


  // ====== 초기화 ======
  loadFromLocal();
  updateTurnUI();
  updateCapsUI();
  fitCanvas();
  window.addEventListener("resize", fitCanvas);
})();
</script>
</body>
</html>
